<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>NDS3: Getting started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NDS3
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">API reference manual</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('getting_started.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Getting started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section will guide you through the development of a simple Device Support based on the NDS3 framework</p>
<p>Here we assume that you already installed the NDS3 library and the NDS3 control system layer of your choice.</p>
<h1><a class="anchor" id="getting_started_concepts"></a>
NDS3 concepts</h1>
<p>Device Supports for the NDS3 framework must declare the device functionalities using a tree-like structure: the tree structure can be composed by:</p>
<ul>
<li>Nodes</li>
<li>Process Variables (PVs)</li>
</ul>
<h2><a class="anchor" id="getting_started_nodes"></a>
Nodes</h2>
<p>A node can contain children nodes or PVs. There are several kind of nodes:</p>
<ul>
<li>plain <a class="el" href="classnds_1_1_node.html" title="A node object that can contain other nodes or PVs as children. ">Node</a>: it is just used to organize the device's component</li>
<li><a class="el" href="classnds_1_1_port.html" title="Represents a node with direct connection with the controlled device. ">Port</a>: it is a node that is able to communicate with an instance of the underlying control system. All the children of a port will communicate with the control system using their parent port</li>
<li><a class="el" href="classnds_1_1_state_machine.html" title="Represents a state machine to be attached to a node. ">StateMachine</a>: a node that comes with few pre-defined children representing the node's state and supplies few functionalities to manage the states</li>
<li><a class="el" href="classnds_1_1_data_acquisition.html">DataAcquisition</a>: a node that comes with few pre-defined children PVs and a state machine useful for controlling data acquisition.</li>
</ul>
<p>The responsability of defining the device structure falls on the constructor of the class that the developer decides to use as representation of the device: when a specific device support is needed then NDS3 will allocate and construct the class that represents the device and expects that the constructor of the class will specify all the nodes and PVs that are needed.</p>
<h2><a class="anchor" id="getting_started_pvs"></a>
Process variables</h2>
<p>PVs, or Process Variables, are variables that are visible from both the Device Support and from the clients connected to the control system.</p>
<p>NDS3 differentiates between input PVs and output PVs;</p>
<ul>
<li>input PVs are WRITTEN by the Device Support and READ by the control system and its clients</li>
<li>output PVs are READ by the Device Suppoer and WRITTEN by the control system and its clients</li>
</ul>
<p>For instance, a device representing a temperature sensor will have one <em>input</em> PV that it will update regularly with the detected temperature, while a power supply could have an <em>output</em> PV that set the desidered output voltage.</p>
<p>NDS3 provides 2 kinds of input and output PVs:</p>
<ul>
<li><a class="el" href="classnds_1_1_p_v_variable_in.html" title="An input PV object that also stores the value so it does not need to delegate the read function...">PVVariableIn</a> and <a class="el" href="classnds_1_1_p_v_variable_out.html" title="An output PV object that also stores the value so it does not need to delegate the read and write fun...">PVVariableOut</a>: the Variable PVs are responsible for storing the value written by the Device Support or by the Control System and are able to supply the internal value on demand to both the Device Support and the Control System. This means that the Device Support can just read or write a value into them when it is convenient, without worrying about the mechanism and the timing that the Control System will use to read/write the PV</li>
<li><a class="el" href="classnds_1_1_p_v_delegate_in.html" title="An input PV that delegates the read operation to an external function. ">PVDelegateIn</a> and <a class="el" href="classnds_1_1_p_v_delegate_out.html" title="An output PV that delegates the read and write operations to two external functions. ">PVDelegateOut</a>: the Delegate PVs will call a predefined Device Support's function when the Control System wants to read or write some data from/to the PV</li>
</ul>
<p>All the input PVs also support the push model, which allows the Device Support to forcefully push data to the Control System at any moment.</p>
<h1><a class="anchor" id="getting_started_thermometer"></a>
A simple Device Support: a thermometer</h1>
<p>The first device that we are going to build is a really simple thermometer: It has a single input PV which supplies the temperature in Kelvin degrees.</p>
<p>The structure of the termomether device is really simple: it provides a root node (a <a class="el" href="classnds_1_1_port.html" title="Represents a node with direct connection with the controlled device. ">Port</a>, so it can communicate with the Control System) that represents the device and an input PV that the control system will read to get the current temperature.</p>
<h2><a class="anchor" id="getting_started_thermometer_source_code"></a>
The source code</h2>
<p>Let's put this in C++ form: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nds_8h.html">nds3/nds.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class declares our device in the contructor and supplies the functionalities to support it</span></div>
<div class="line"><span class="comment"></span><span class="keyword">class </span>Thermometer</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Constructor. Here we setup the device structure</span></div>
<div class="line"><span class="comment"></span>    Thermometer(<a class="code" href="classnds_1_1_factory.html">nds::Factory</a> &amp;factory,</div>
<div class="line">                <span class="keyword">const</span> std::string &amp;deviceName,</div>
<div class="line">                <span class="keyword">const</span> <a class="code" href="namespacends.html#a1623ccf32bf1883cc75d22e2471c535b">nds::namedParameters_t</a> &amp;parameters)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="classnds_1_1_port.html">nds::Port</a> rootNode(deviceName);</div>
<div class="line">        rootNode.addChild(<a class="code" href="classnds_1_1_p_v_delegate_in.html">nds::PVDelegateIn&lt;double&gt;</a>(<span class="stringliteral">&quot;Temperature&quot;</span>, std::bind(&amp;Thermometer::getTemperature, </div>
<div class="line">                                                                             <span class="keyword">this</span>, </div>
<div class="line">                                                                             std::placeholders::_1, </div>
<div class="line">                                                                             std::placeholders::_2)));</div>
<div class="line"></div>
<div class="line">        rootNode.initialize(<span class="keyword">this</span>, factory);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> getTemperature(timespec* pTimestamp, <span class="keywordtype">double</span>* pValue)</div>
<div class="line">    {</div>
<div class="line">        *pValue = 10; <span class="comment">// It is always cold in here</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// If we want to load our device support dynamically then we have to compile it</span></div>
<div class="line"><span class="comment">//  as a dynamic module and we have to provide the functions to allocate it,</span></div>
<div class="line"><span class="comment">//  deallocate it and retrieve its name</span></div>
<div class="line"><span class="comment"></span><a class="code" href="definitions_8h.html#abae220b9d7ab927324ef6caa20107576">NDS_DEFINE_DRIVER</a>(Thermometer, Thermometer)</div>
<div class="line"></div>
</div><!-- fragment --><p>What did we do with this code?</p>
<p>The constructor takes three parameters passed by NDS3 when it allocates the device:</p>
<ul>
<li>factory: this parameter contains an interface to the Control System that requested the creation of the device</li>
<li>deviceName: the name with which the device should be presented to the control system. Usually it is used as name of the root node</li>
<li>parameters: a map of named parameters that are specific for each Device Support. The implementor of the Device Support can decide how to use the parameters</li>
</ul>
<p>We allocate a <a class="el" href="classnds_1_1_port.html" title="Represents a node with direct connection with the controlled device. ">Port</a> as root node: a <a class="el" href="classnds_1_1_port.html" title="Represents a node with direct connection with the controlled device. ">Port</a> node holds a reference to the underlying control system. PVs can be added only to Ports or to nodes that have a <a class="el" href="classnds_1_1_port.html" title="Represents a node with direct connection with the controlled device. ">Port</a> up in the hierarchy.</p>
<p>The variable rootNode contains a shared pointer to the acual implementation of the <a class="el" href="classnds_1_1_port.html" title="Represents a node with direct connection with the controlled device. ">Port</a>: when we will register rootNode with the Control System then NDS will take care of storing the shared pointer internally and therefore the <a class="el" href="classnds_1_1_port.html" title="Represents a node with direct connection with the controlled device. ">Port</a> will continue to exists even after rootNode goes out of scope.</p>
<dl class="section attention"><dt>Attention</dt><dd>In NDS3, all the device components just hold shared pointers to the actual components implementation.</dd></dl>
<p>After we declare the root node then we call <a class="el" href="classnds_1_1_node.html#a6081d6501b51914293d4f22b5db74697" title="Add a child node or record to this node. This node will take ownership of the added one and will take...">nds::Node::addChild()</a> on it to add a child component, in our case a <a class="el" href="classnds_1_1_p_v_delegate_in.html" title="An input PV that delegates the read operation to an external function. ">PVDelegateIn</a> that handles double floating point values. PVDelegateIN PVs are not able to store the value internally but rely on a function that is called when the control system wants to read the value. In our case we provide a callback to getTemperature() which always return 10 degrees Kelvin.</p>
<p>Finally we call initialize() which registers the root node and its children with the Control System.</p>
<p>If we are running our Device Support using EPICS as control system then the following PV will be available:</p>
<pre class="fragment">rootNodeName-Temperature
</pre><p>Issuing a dbpf rootNodeName-Temperature.PROC 1 will cause the framework to call getTemperature() and fill the PV with the value 10.</p>
<h2><a class="anchor" id="getting_started_thermometer_compilation"></a>
Compiling the source code</h2>
<p>The Makefile for a NDS3 device is quite straightforward: it does not depend on EPICS or any other Control System you may be using and you just have to make sure that it includes the shared library nds3 and specify the flag NDS3_DLL (tells the compiler that the NDS3 is being linked dynamically).</p>
<p>An example for our thermometer: </p>
<div class="fragment"><div class="line">CXX = g++</div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># We enable the c++0x flag, plus we define the NDS3_DLL preprocessor macro.</span></div>
<div class="line"><span class="preprocessor"></span>CXXFLAGS = -std=c++0x -Wall -Wextra -pedantic -fPIC -pthread -DNDS3_DLL</div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># Flags passed to gcc during linking</span></div>
<div class="line"><span class="preprocessor"></span>LINK = -shared -fPIC -Wl,-as-needed</div>
<div class="line"></div>
<div class="line"><span class="preprocessor"># Name of our device library</span></div>
<div class="line"><span class="preprocessor"></span>TARGET = libthermometer.so</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># We specify that we depend on NDS3</span></div>
<div class="line"><span class="preprocessor"></span>LIBS = -lnds3</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># We assume that all the .cpp files are in the src folder</span></div>
<div class="line"><span class="preprocessor"></span>SRCS = thermometer.cpp</div>
<div class="line"></div>
<div class="line">OBJS = $(SRCS:.cpp=.o)</div>
<div class="line"># Rules <span class="keywordflow">for</span> building</div>
<div class="line">$(TARGET): $(OBJS)</div>
<div class="line">    $(CXX) $(LINK) -o $@ $^ $(LIBS)</div>
<div class="line"></div>
<div class="line">.PHONY: clean</div>
<div class="line">clean:</div>
<div class="line">    $(RM) $(TARGET) $(OBJS)</div>
</div><!-- fragment --><p>This makefile will generate the shared module libthermometer.so. Now you can load the device into your NDS3 control system of choice and run it.</p>
<h2><a class="anchor" id="getting_started_thermometer_using_device_epics"></a>
Using the Thermometer device on EPICS</h2>
<p>On EPICS you will use the command  to load the shared module and the command  to allocate and construct the device.</p>
<p>For instance: </p>
<pre class="fragment">epics&gt; ndsLoadDriver path/to/libthermometer.so
epics&gt; ndsCreateDevice Thermometer testDevice
epics&gt; iocInit
epics&gt; dbl
testDevice-Temperature
epics&gt; dbpf testDevice-Temperature.PROC 1
epics&gt; dbgf testDevice-Temperature
10
</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Oct 26 2017 20:31:52 for NDS3 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>

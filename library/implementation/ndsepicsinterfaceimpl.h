#ifndef NDSEPICSINTERFACEIMPL_H
#define NDSEPICSINTERFACEIMPL_H

#include <asynPortDriver.h>
#include <string>
#include <vector>
#include "ndspvbaseimpl.h"
#include "ndsinterfacebaseimpl.h"

namespace nds
{

class PVBase;

/**
 * @internal
 * @brief The AsynInterface class. Allocated by AsynPort
 *        to communicate with the AsynDriver
 */
class EpicsInterfaceImpl: public InterfaceBaseImpl, asynPortDriver
{
public:
    EpicsInterfaceImpl(const std::string& portName);

    virtual void registerPV(std::shared_ptr<PVBaseImpl> pv);

    virtual void registrationTerminated();

    virtual void push(std::shared_ptr<PVBaseImpl> pv, const timespec& timestamp, const std::int32_t& value);
    virtual void push(std::shared_ptr<PVBaseImpl> pv, const timespec& timestamp, const double& value);
    virtual void push(std::shared_ptr<PVBaseImpl> pv, const timespec& timestamp, const std::vector<std::int32_t> & value);

    virtual asynStatus readInt32(asynUser *pasynUser, epicsInt32 *value);
    virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);

    virtual asynStatus readFloat64(asynUser *pasynUser, epicsFloat64 *value);
    virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);

    virtual asynStatus readInt32Array(asynUser *pasynUser, epicsInt32 *value,
                                                  size_t nElements, size_t *nIn);
    virtual asynStatus writeInt32Array(asynUser *pasynUser, epicsInt32 *value,
                                                   size_t nElements);

    virtual asynStatus drvUserCreate(asynUser *pasynUser, const char *drvInfo,
                                     const char **pptypeName, size_t *psize);

    timespec convertEpicsTimeToUnixTime(const epicsTimeStamp& time);
    epicsTimeStamp convertUnixTimeToEpicsTime(const timespec& time);

private:
    template<typename T, typename interruptType>
    void pushOneValue(std::shared_ptr<PVBaseImpl> pv, const timespec& timestamp, const T& value, void* interruptPvt);

    template<typename T>
    asynStatus writeOneValue(asynUser* pasynUser, const T& pValue);

    template<typename T>
    asynStatus readOneValue(asynUser* pasynUser, T* pValue);

    template<typename T>
    asynStatus readArray(asynUser *pasynUser, T* pValue, size_t nElements, size_t *nIn);

    template<typename T>
    asynStatus writeArray(asynUser *pasynUser, T* pValue, size_t nElements);

    std::vector<std::shared_ptr<PVBaseImpl> > m_pvs;

    std::map<std::string, size_t> m_pvNameToReason;

    std::string m_autogeneratedDB;
};

}

#endif // NDSEPICSINTERFACEIMPL_H

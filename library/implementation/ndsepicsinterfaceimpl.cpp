#include "ndsepicsinterfaceimpl.h"
#include "ndspvbaseimpl.h"
#include "ndsportImpl.h"
#include "../include/nds3/ndspvbase.h"

#include <cstdint>
#include <sstream>
#include <ostream>
#include <fstream>

namespace nds
{

EpicsInterfaceImpl::EpicsInterfaceImpl(const std::string& portName): InterfaceBaseImpl(portName), asynPortDriver(
                                                               portName.c_str(),
                                                               256,    /* maxAddr */
                                                               0,
                                                               //asynCommonMask |
                                                               asynDrvUserMask |
                                                               //asynOptionMask |
                                                               asynInt32Mask |
                                                               //asynUInt32DigitalMask |
                                                               asynFloat64Mask  //|
                                                               //asynOctetMask |
                                                               //asynInt8ArrayMask |
                                                               //asynInt16ArrayMask |
                                                               //asynInt32ArrayMask |
                                                               //asynFloat32ArrayMask |
                                                               //asynFloat64ArrayMask |
                                                               //asynGenericPointerMask,   /* Interface mask */
                                              ,
                                                               asynInt32Mask |
                                                               //asynUInt32DigitalMask |
                                                               asynFloat64Mask // |
                                                               //asynOctetMask |
                                                               //asynInt8ArrayMask |
                                                               //asynInt16ArrayMask |
                                                               //asynInt32ArrayMask |
                                                               //asynFloat32ArrayMask |
                                                               //asynFloat64ArrayMask |
                                                               //asynGenericPointerMask,            /* Interface mask */
                                                               , ASYN_CANBLOCK | ASYN_MULTIDEVICE,  /* asynFlags. */
                                                               1,                                 /* Autoconnect */
                                                               0,                                 /* Default priority */
                                                               0)
{
}

std::string datatTypeToEpicsString(dataType_t dataType)
{
    switch(dataType)
    {
    case dataInt32:
        return "asynInt32";
    case dataFloat64:
        return "asynFloat64";
    default:
        throw;
    }
}

void EpicsInterfaceImpl::registerPV(std::shared_ptr<PVBaseImpl> pv)
{
    m_pvs.push_back(pv);

    std::string type = pv->getType();
    if(!type.empty())
    {
        int portAddress(0);
        std::ostringstream dbEntry;

        std::string externalName(pv->getFullName());
        if(!pv->getInterfaceName().empty())
        {
            externalName = pv->getPort()->getFullName() + "-" + pv->getInterfaceName();
        }
        dbEntry << "record(" << type << ", \"" << externalName << "\") {" << std::endl;
        dbEntry << "    field(DESC, \"" << pv->getDescription() << "\")" << std::endl;
        dbEntry << "    field(DTYP, \"" << datatTypeToEpicsString(pv->getDataType()) << "\")" << std::endl;
        dbEntry << "    field(INP, \"@asyn(" << pv->getPort()->getFullName() << ", " << portAddress<< ")" << pv->getFullNameFromPort() << "\")" << std::endl;
        //dbEntry << "    field(OUT, \"@asyn(" << pv->getPort()->getFullName() << ", " << portAddress<< ")" << pv->getFullNameFromPort() << "\")" << std::endl;
        dbEntry << "    field(SCAN, \"I/O Intr\")" << std::endl;
        dbEntry << "}" << std::endl << std::endl;
        dbEntry.flush();

        m_autogeneratedDB += dbEntry.str();
    }
}

void EpicsInterfaceImpl::registrationTerminated()
{
    // Save the records in a temporary file
    ///////////////////////////////////////
    std::string fileName("auto_generated_" + m_portName + ".db");
    std::ofstream outputStream(fileName.c_str());
    outputStream << m_autogeneratedDB;
    outputStream.flush();
}

void EpicsInterfaceImpl::push(const timespec& timestamp, const pvList_t& pvList)
{

}


asynStatus EpicsInterfaceImpl::readInt32(asynUser *pasynUser, epicsInt32 *value)
{
    timespec timestamp;
    if(pasynUser->timestamp.secPastEpoch == 0 && pasynUser->timestamp.nsec == 0)
    {
        clock_gettime(CLOCK_MONOTONIC, &timestamp);
    }
    m_pvs[pasynUser->reason]->read(&timestamp, (std::int32_t*)value);

    return asynSuccess;
}

asynStatus EpicsInterfaceImpl::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
    timespec timestamp;

    m_pvs[pasynUser->reason]->write(timestamp,(std::int32_t) value);
    return asynSuccess;
}

asynStatus EpicsInterfaceImpl::readFloat64(asynUser *pasynUser, epicsFloat64 *value)
{
    timespec timestamp;
    if(pasynUser->timestamp.secPastEpoch == 0 && pasynUser->timestamp.nsec == 0)
    {
        clock_gettime(CLOCK_MONOTONIC, &timestamp);
    }
    m_pvs[pasynUser->reason]->read(&timestamp, (double*)value);

    return asynSuccess;
}

asynStatus EpicsInterfaceImpl::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
    timespec timestamp;

    m_pvs[pasynUser->reason]->write(timestamp,(double) value);
    return asynSuccess;
}

asynStatus EpicsInterfaceImpl::drvUserCreate(asynUser *pasynUser, const char *drvInfo,
                                 const char **pptypeName, size_t *psize)
{
    for(size_t scanReasons(0), endReasons(m_pvs.size()); scanReasons != endReasons; ++scanReasons)
    {
        if(m_pvs[scanReasons]->getFullNameFromPort() == drvInfo)
        {
            pasynUser->reason = scanReasons;
            pasynUser->userData = m_pvs[scanReasons].get();
            return asynSuccess;
        }
    }
    return asynError;
}

timespec EpicsInterfaceImpl::convertEpicsTimeToUnixTime(const epicsTimeStamp& time)
{
    timespec unixTime;

    return unixTime;

}

epicsTimeStamp EpicsInterfaceImpl::convertUnixTimeToEpicsTime(const timespec& time)
{
    epicsTimeStamp epicsTime;
    return epicsTime;

}

}

#include "ndsinterfaceimpl.h"
#include "ndspvbaseimpl.h"
#include "ndsportImpl.h"
#include "../include/nds3/ndspvbase.h"

#include <cstdint>
#include <sstream>
#include <ostream>

namespace nds
{

InterfaceImpl::InterfaceImpl(const std::string& portName): asynPortDriver(
                                                               portName.c_str(),
                                                               256,    /* maxAddr */
                                                               0,
                                                               //asynCommonMask |
                                                               asynDrvUserMask |
                                                               //asynOptionMask |
                                                               asynInt32Mask |
                                                               //asynUInt32DigitalMask |
                                                               asynFloat64Mask  //|
                                                               //asynOctetMask |
                                                               //asynInt8ArrayMask |
                                                               //asynInt16ArrayMask |
                                                               //asynInt32ArrayMask |
                                                               //asynFloat32ArrayMask |
                                                               //asynFloat64ArrayMask |
                                                               //asynGenericPointerMask,   /* Interface mask */
                                              ,
                                                               asynInt32Mask |
                                                               //asynUInt32DigitalMask |
                                                               asynFloat64Mask // |
                                                               //asynOctetMask |
                                                               //asynInt8ArrayMask |
                                                               //asynInt16ArrayMask |
                                                               //asynInt32ArrayMask |
                                                               //asynFloat32ArrayMask |
                                                               //asynFloat64ArrayMask |
                                                               //asynGenericPointerMask,            /* Interface mask */
                                                               , ASYN_CANBLOCK | ASYN_MULTIDEVICE,  /* asynFlags. */
                                                               1,                                 /* Autoconnect */
                                                               0,                                 /* Default priority */
                                                               0)
{
}

std::string datatTypeToEpicsString(dataType_t dataType)
{
    switch(dataType)
    {
    case dataInt32:
        return "asynInt32";
    case dataFloat64:
        return "asynFloat64";
    default:
        throw;
    }
}

void InterfaceImpl::registerPV(std::shared_ptr<PVBaseImpl> pv)
{
    m_pvs.push_back(pv);

    std::string type = pv->getType();
    if(!type.empty())
    {
        int portAddress(0);
        //getAddress(pAsynUser, &portAddress);
        std::ostringstream dbEntry;
        dbEntry << "record(" << type << ", " << pv->getFullNameFromPort() << ") {" << std::endl;
        dbEntry << "    field(DESC, \"" << pv->getDescription() << "\")" << std::endl;
        dbEntry << "    field(DTYP, \"" << datatTypeToEpicsString(pv->getDataType()) << "\")" << std::endl;
        dbEntry << "    field(INP, \"@asyn(" << pv->getPort()->getFullName() << ", " << portAddress<< ")" << pv->getFullNameFromPort() << "\")" << std::endl;
        dbEntry << "    field(OUT, \"@asyn(" << pv->getPort()->getFullName() << ", " << portAddress<< ")" << pv->getFullNameFromPort() << "\")" << std::endl;
        dbEntry << "}" << std::endl << std::endl;

        m_autogeneratedDB += dbEntry.str();
    }
}

asynStatus InterfaceImpl::readInt32(asynUser *pasynUser, epicsInt32 *value)
{
    timespec timestamp;
    if(pasynUser->timestamp.secPastEpoch == 0 && pasynUser->timestamp.nsec == 0)
    {
        clock_gettime(CLOCK_MONOTONIC, &timestamp);
    }
    m_pvs[pasynUser->reason]->read(&timestamp, (std::int32_t*)value);

    return asynSuccess;
}

asynStatus InterfaceImpl::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
    timespec timestamp;

    m_pvs[pasynUser->reason]->write(timestamp,(std::int32_t) value);
    return asynSuccess;
}

asynStatus InterfaceImpl::readFloat64(asynUser *pasynUser, epicsFloat64 *value)
{
    timespec timestamp;
    if(pasynUser->timestamp.secPastEpoch == 0 && pasynUser->timestamp.nsec == 0)
    {
        clock_gettime(CLOCK_MONOTONIC, &timestamp);
    }
    m_pvs[pasynUser->reason]->read(&timestamp, (double*)value);

    return asynSuccess;
}

asynStatus InterfaceImpl::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
    timespec timestamp;

    m_pvs[pasynUser->reason]->write(timestamp,(double) value);
    return asynSuccess;
}

asynStatus InterfaceImpl::drvUserCreate(asynUser *pasynUser, const char *drvInfo,
                                 const char **pptypeName, size_t *psize)
{
    for(size_t scanReasons(0), endReasons(m_pvs.size()); scanReasons != endReasons; ++scanReasons)
    {
        if(m_pvs[scanReasons]->getFullNameFromPort() == drvInfo)
        {
            pasynUser->reason = scanReasons;
            pasynUser->userData = m_pvs[scanReasons].get();
            return asynSuccess;
        }
    }
    return asynError;
}

timespec InterfaceImpl::convertEpicsTimeToUnixTime(const epicsTimeStamp& time)
{
    timespec unixTime;

    return unixTime;

}

epicsTimeStamp InterfaceImpl::convertUnixTimeToEpicsTime(const timespec& time)
{
    epicsTimeStamp epicsTime;
    return epicsTime;

}

}
